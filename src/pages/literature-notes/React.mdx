---
title: "React.js"
date: "2025-11-10"
---

# React.js

## What?

- by Kent C. Dodds

### Some Basic Concepts

- Create React App (CRA)
- JSX (JavaScript Syntax Extension)
- React Components - CamelCase, reusable UI
  - Functional Components - stateless (`const CompName = () => { return (<> </>)}`)
  - Class based components - stateful, state render
- React Props vs React State & setState - built-in React object, async, å¼‚æ­¥
  - What is the difference between props and state?
- Conditional Rendering - logical, ternary, switch, IIFE
- Component Life Cycles - 4 stages (lifecycle methods)
- React Keys & React Map List
- Composition vs Inheritance
  - Composition (What they do)
    - åƒ tag ç»„åˆ
    - More flexible (predict future usage)
    - Reusable
    - Use of Closure
    - Donâ€™t need to duplicate logic
  - Inheritance (What they are)
    - åƒåˆ†ç±» å½’ç±»

### Some Advanced Topics

- React Hooks - use CamelCase
  - React Hooks - use CamelCase
  - React Custom Hooks - reusable
- React Context - global, pass props
  - React Context - global, pass props
- React Refs (useRef() - no re-render, store previous value, persist ref.current)
  - What are refs in React? When should they be used? - createRef, access DOM, access element, return refs
- Render Props
- Higher-Order Component é«˜é˜¶ç»„ä»¶ - HOC, argument component, return component
- Portals
- Error Boundaries
- React Fiber Architecture

### What React Ecosystem (Tools) ?

- React Routers
  - Tanstack Router (React Location)
  - React Router v6
  - Reach Router
- SSR (Server Side Rendering) æœåŠ¡ç«¯æ¸²æŸ“ - html on request
  - Next.js - vercel, ssr
  - Remix
  - After.js
  - Rogue
- SSG (Static Site Generation) é™æ€ç”Ÿæˆ - seo
  - Next.js - vercel, ssr
  - Gatsby
- React API calls
  - ReST API (ReSTful APIs microservices) 
    - fetch() (network requests) - async
    - SuperAgent
    - Axios
    - superagent
  - GraphQL 
    - Apollo - GraphQL
    - Relay Modern
    - urql
  - use-http
  - Other data Fetching (Official Comparison [ğŸ”—](https://juejin.cn/post/6937833844837974053#:~:text=Provider%20%E3%80%82%E6%9B%B4%E5%8A%A0%E8%BD%BB%E4%BE%BF-,%E5%AE%98%E7%BD%91%E7%9B%B8%E5%85%B3%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94%E8%A1%A8%E6%A0%BC,-React%20Query))
    - React Query (TanStack Query) - async state manager, data fetch, cache, refetch, mutation
    - swr / Vercel - data fetch
    - Apollo Client [ğŸ”—](https://www.apollographql.com/docs/react/#:~:text=Introduction%20to-,apollo%20client,-Apollo%20Client%20is)
    - RTK-Query - data fetch [ğŸ”—](https://redux-toolkit.js.org/rtk-query/overview#:~:text=RTK%20Query%20Overview-,rtk%20query,-Overview)
- React Testing
  - **Rendering component trees**
    - Unit Testing
      - Jest - unit, test runner
      - Vitest - test runner
      - Mocha - test runner, test framework
      - Chai - assertion library
      - React Testing Library (RTL) - testing library
      - Enzyme - testing library
      - Sinon - testing plugin
      - AVA
      - Tape
    - Integration Testing
      - Karma - test runner
    - Component Tools
      - Storybook
      - Ladle - uber
  - **Running a complete app**
    - E2E (End-to-end) ç«¯åˆ°ç«¯æµ‹è¯• Testing/Acceptance/functional testing
      - Playwright - e2e
      - Selenium , Webdriver
      - Cypress - e2e, test runner, framework
      - Puppeteer - library
      - Cucumber - Gherkin, BDD
      - Nightwatch.js
- React State Management
  1. Component State
     - useState() - sync
     - useReducer() - multiple useStates, complex state
     - React Custom Hooks - reusable
  2. Application State (Client State)
     1. Local State
        - Component State/Context API
     2. Global State (multiple components)
        - Context / State (use State & useState **FIRST**)
          - Why didn't useState work? [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=why%20didn't%20usestate%20work%3F)
            - I need a global â‡’ Jotai - atom, immutable state, auto render, mid-large app
              - specify which atom gets re-render
            - I want to mutate â‡’ Valtio - mutable state, auto render, proxy, small app
            - I need a store/machine (actions, events etc) â‡’ Zustand - immutable state, manual render, flux, large app, context, outside React
          - Data-centric - external store (react components are used to represent those data)
            - Zustand - immutable state, manual render, flux, large app, context, outside React
              - Where state resides
                - module (outside react)[ğŸ”—](https://blog.axlight.com/posts/when-i-use-valtio-and-when-i-use-jotai/#:~:text=data-centric%20and%20component-centric%20approaches)
              - How to control re-render
                - selector (ref equality check)[ğŸ”—](https://blog.axlight.com/posts/when-i-use-valtio-and-when-i-use-jotai/#:~:text=data-centric%20and%20component-centric%20approaches)
              - Zustand uses flux pattern and is suitable for mostly large scale apps. It is an alternative for Redux. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=zustand%20uses%20flux%20pattern%20and%20is%20suitable%20for%20mostly%20large%20scale%20apps.%20it%20is%20an%20alternative%20for%20redux.)
                - A big advantage of zustand is the ability to synchronously update state from outside of components. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=a%20big%20advantage%20of%20zustand%20is%20the%20ability%20to%20synchronously%20update%20state%20from%20outside%20of%20components.%20)
                - I prefer Zustand. Tiny, straightforward, scalable. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=i%20prefer%20zustand.%20tiny%2C%20straightforward%2C%20scalable.)
              - I use Zustand and Jotai. I would also use both in the same application since they are based on different state management models. I don't use Valtio because I try to avoid proxy-based reactivity in React. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=I%20use%20Zustand,reactivity%20in%20React.)
              - top-down [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=Zustand%20-%20offers%20a-,top-down,-approach%20to%20the)
                - top-down you would model your state as a larger object with some smaller nested objects, then the selector would be responsible for subscribing only to the smaller nested pieces that the component needs. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=top-down%20you%20would%20model%20your%20state%20as%20a%20larger%20object%20with%20some%20smaller%20nested%20objects%2C%20then%20the%20selector%20would%20be%20responsible%20for%20subscribing%20only%20to%20the%20smaller%20nested%20pieces%20that%20the%20component%20needs.)
                - better for modeling the app domain, [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=better%20for%20modeling%20the%20app%20domain%2C)
              - zustand for centralised javascript stores. if you have a state schema, or your state is json, this will make sense. works well in teams. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=zustand%20for%20centralised%20javascript%20stores.%20if%20you%20have%20a%20state%20schema%2C%20or%20your%20state%20is%20json%2C%20this%20will%20make%20sense.%20works%20well%20in%20teams.)
              - Valtio's premise is to have global mutable objects. When used in components, the component is automatically re-rendered when the value changes. It works great, but it may cause some hard-to-track bugs when used without discipline in large projects.
                Zustand is very strict, and this is great for large projects, particularly enterprise ones.
                [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=Valtio's%20premise%20is,particularly%20enterprise%20ones.)
            - Valtio - mutable state, auto render, proxy, small app
              - (react-tracked + Zustand - immutable state, manual render, flux, large app, context, outside React)
              - How to control re-render
                - Usage tracking (with proxies)
              - Where state resides
                - Module (outside react)
              - Valtio uses proxy pattern, is mutable, and mostly suitable for small scale apps. It is an alternative for Mobx. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=valtio%20uses%20proxy%20pattern%2C%20is%20mutable%2C%20and%20mostly%20suitable%20for%20small%20scale%20apps.%20it%20is%20an%20alternative%20for%20mobx.)
              - **Valtio** mostly optimizes for state writing by allowing you to directly mutate the global state. To me it's similar to Zustand, except that state updates are made simpler. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=valtio%20-%20mostly%20optimizes%20for%20state%20writing%20by%20allowing%20you%20to%20directly%20mutate%20the%20global%20state.%20to%20me%20it's%20similar%20to%20zustand%2C%20except%20that%20state%20updates%20are%20made%20simpler.)
              - **Valtio** good for a global state that's detached from React component tree. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=valtio%20-%20good%20for%20a%20global%20state%20that's%20detached%20from%20react%20component%20tree.)
              - it's best in large data-centric applications [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=it's%20best%20in%20large%20data-centric%20applications)
              - valtio is fantastic for smaller projects that have no problem with mutation and updating state from multiple place. works best in everything you do personally. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=valtio%20is%20fantastic%20for%20smaller%20projects%20that%20have%20no%20problem%20with%20mutation%20and%20updating%20state%20from%20multiple%20place.%20works%20best%20in%20everything%20you%20do%20personally.)
          - Component-centric (React Centric) - internal store (Design components first)
            - Jotai - atom, immutable state, auto render, mid-large app
              - How to control re-render
                - Dependency tracking without proxies
              - Where state resides
                - Component (inside react)
              - middle-large scale apps. It is an alternative for Recoil or useContext/useState.[ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=jotai%20uses%20atomic%20pattern%20and%20is%20suitable%20for%20mostly%20middle-large%20scale%20apps.%20it%20is%20an%20alternative%20for%20recoil%20or%20usecontext%2Fusestate.)
              - for smaller application / personal projects
              - bottom-up [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=because%20of%20its-,bottom-up,-style.%20You%20first)
                - it's trivial to subscribe to only the state you use, but it's more work to combine that state into a cohesive whole. The selectors are often used to combine smaller atoms into an object with the state that's meant to go together. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=bottom-up%2C%20it's%20trivial%20to%20subscribe%20to%20only%20the%20state%20you%20use%2C%20but%20it's%20more%20work%20to%20combine%20that%20state%20into%20a%20cohesive%20whole.%20the%20selectors%20are%20often%20used%20to%20combine%20smaller%20atoms%20into%20an%20object%20with%20the%20state%20that's%20meant%20to%20go%20together.)
              - better for performance-driven apps that have many moving parts that require a large amount of read-write operations to small pieces of state. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=better%20for%20performance-driven%20apps%20that%20have%20many%20moving%20parts%20that%20require%20a%20large%20amount%20of%20read-write%20operations%20to%20small%20pieces%20of%20state.)
              - I think the atomic pattern can accomplish everything zustand can, but more, and with less boilerplate. [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=i%20think%20the%20atomic%20pattern%20can%20accomplish%20everything%20zustand%20can%2C%20but%20more%2C%20and%20with%20less%20boilerplate.)
              - jotai for atomic, dispersed state bits, similar to useState but render optimised and with a few extras (state derivatives). works well in teams. [ğŸ”—](<https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=jotai%20for%20atomic%2C%20dispersed%20state%20bits%2C%20similar%20to%20usestate%20but%20render%20optimised%20and%20with%20a%20few%20extras%20(state%20derivatives).%20works%20well%20in%20teams.>)
  3. Server State (Server Cache)
     - React Query (TanStack Query) - async state manager, data fetch, cache, refetch, mutation
     - Redux - RTK-Query, flux
       - top-down [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=what%20I've%20experienced%2C-,top-down,-(Zustand%2C%20Redux%2C%20Mobx)
     - swr / Vercel - data fetch
  4. URL State
     1. Tanstack Router (React Location)
  - Other state managers
    - MobX - proxy
      - top-down [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=what%20I've%20experienced%2C-,top-down,-(Zustand%2C%20Redux%2C%20Mobx)
    - Recoil - state, meta, atom
      - Bottom-up [ğŸ”—](https://www.reddit.com/r/reactjs/comments/wec4oo/zustand_vs_jotai_vs_valtio_which_state_management/#:~:text=the%20state%20structure.-,bottom-up,-(Jotai%2C%20Recoil%2C%20hookState)
      - dependency tracking without proxies
      - state resides in component (inside react)
    - Async actions (Side Effects)
    - Redux Thunk
    - Redux Better Promise
    - Redux Saga
    - Redux Observable
    - Helpers
    - Rematch
    - Reselect
    - Data persistence
    - Redux Persist
    - Redux Phoenix
    - Redux Form
    - react-tracked
    - XState
- React Form Component
  - React Hook Form
  - Formik - form
  - Final Form
  - Downshift - autocomplete
  - **Validation**
    - Yup orÂ Zod - run-time , hookform/resolvers
  - **Input:**Â [React IMask](https://github.com/uNmAnNeR/imaskjs/tree/master/packages/react-imask),Â [React-number-format](https://github.com/s-yadav/react-number-format),Â [React Credit Cards](https://github.com/amaroteam/react-credit-cards)
  - React Calendar Component
    - [React-calendar](https://github.com/wojtekmaj/react-calendar)
- React Styling
  - Styled
    - Chakra UI
    - MUI (Material UI)
    - Ant Design (AntD)
  - Unstyled (Headless UI)
    - Radix UI - primitives
    - Headless UI #Tailwind
    - React Aria
    - Table
      - TanStack Table
  - CSS Frameworks
    - React-Bootstrap
    - Bootstrap (Bootstrap5)
    - **Tailwind CSS**
    - Bulma - donâ€™t come with js framework components by default
- React Mobile
  - React Native
  - Cordova/PhoneGap

### What are the Rules?

1. Never Mutate The State with = sign - react rule

## Why?

### Why React?

## How?

### How to optimize?

- Optimize Re-renders
  - How can you optimize performance for a function component that always renders the same way?
  1. Lazy Loading: Lazy loading is a technique that allows you to load certain components or modules only when they are needed. This can help to reduce the amount of initial code that needs to be loaded and can also help to reduce the overall size of your JavaScript bundle.
  2. Use Memoization: Memoization is a technique that allows you to cache the results of expensive function calls. This can help to reduce the amount of time that your application spends recalculating values and can improve overall performance.
- Optimize System
  - Restructure code
  - SRP (Single-responsibility principle) å•ä¸€èŒè´£åŸåˆ™ - modules

1. Use Production Builds: When deploying your React application, make sure to use a production build. This will reduce the size of the JavaScript bundle and enable optimizations such as minification, which can significantly improve performance.
2. Code Splitting - modular, modularizing
3. Use Virtual DOM: React uses a virtual DOM to manage updates to the UI. By using a virtual DOM, React can update the UI more efficiently and can help to improve performance.
4. Use React Profiler: React Profiler is a built-in tool that can help you to identify performance bottlenecks in your application. By using React Profiler, you can identify which components are causing performance issues and take steps to optimize them.
5. Use Performance Budgets: Setting performance budgets can help to ensure that your application remains fast and responsive. By setting budgets for things like load time and rendering performance, you can ensure that your application remains performant even as it grows in complexity.
6. Use Server-Side Rendering: Server-side rendering can help to improve the initial load time of your application and improve overall performance. By rendering your application on the server and sending the HTML to the client, you can reduce the amount of JavaScript that needs to be loaded and improve the time-to-first-byte.
